<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SAST授课-入门Redis&了解云原生 | Whitea's Blog</title>
<meta name=keywords content="SAST"><meta name=description content="SASTWeb组2025后端方向第一次授课"><meta name=author content="Whitea"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/images/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/images/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/images/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/sast/2025-first-class/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/sast/2025-first-class/"><meta property="og:site_name" content="Whitea's Blog"><meta property="og:title" content="SAST授课-入门Redis&了解云原生"><meta property="og:description" content="SASTWeb组2025后端方向第一次授课"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-27T11:30:03+00:00"><meta property="article:modified_time" content="2025-02-27T11:30:03+00:00"><meta property="article:tag" content="SAST"><meta property="og:image" content="http://localhost:1313/%3Cimage%20path/url%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Cimage%20path/url%3E"><meta name=twitter:title content="SAST授课-入门Redis&了解云原生"><meta name=twitter:description content="SASTWeb组2025后端方向第一次授课"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"SAST授课-入门Redis\u0026了解云原生","item":"http://localhost:1313/posts/sast/2025-first-class/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SAST授课-入门Redis\u0026了解云原生","name":"SAST授课-入门Redis\u0026了解云原生","description":"SASTWeb组2025后端方向第一次授课","keywords":["SAST"],"articleBody":"入门Redis \u0026 了解云原生 第一部分：Redis快速入门 初步认识 Redis 是一个开源（BSD 许可）的，内存中的键值对（K-V）存储系统，它可以用作 数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings），散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询 bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions）和不同级别的磁盘持久化（persistence）， 并通过Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）\n你得知道：\nRedis是Nosql型的非关系型数据库（Nosql：Not Only sql） Redis是基于内存存储的，速度快，当然也支持数据的持久化 Redis是在处理客户端请求的时候是单线程的，在处理客户端连接时候使用IO多路复用技术 Redis其实是支持事务的，但是一次性、顺序性、排他性的执行队列中的命令，是不支持回滚的，缺乏传统ACID事务的隔离性和持久性 安装 Windows： 官方推荐使用WSL2官网指南，当然也可以在Github上下载Zip,解压缩到本地，然后在安装目录执行redis-server.exe redis.windows.conf即可临时启动 Linux \u0026 Mac： 使用包管理器安装即可\n但待会我们会讲容器技术，这会让Redis的安装使用更加方便😀\n常用命令 使用select切换数据库：select [number] （redis共16个数据库） 查看数据库大小：DBSIZE 查看库内容：keys * 判断某个值存在：exists key 存储数据：set key value云 数据限时：expire key number\\setex key number value限时多少秒后数据失效，ttl key查询还有多久截止 查看key类型：type key 删除数据库：flushall or flushdb DbName 批量插入、获取：mset k1 v1 k2 v2...\\mget k1 k2 k3... 五大基本数据类型 不用记，用的时候查就行🤣\nString 拼接key的value和value，并返回新value的长度：append keyName value 获取字符串长度：strlen key 对数字内容String自增、自减：incr key，decr key 任意步长自增：incrby key number 截取子串：getrange key start end（截取后包括start end所在的值，end为-1则获取所有项，java则不会包含end） 替换子串：setrange key offset value（从offset开始将value替换后面的内容） 如果存在则：setnx key value 插入一个json字符串：set user:1 {name:JayChou,id:1} List：所有的List命令都是l开头 插入：lpush listName value(头插法)\\rpush listName value(尾插法)} 获取：lrange listName start end，lindex listName index 移除：lpop\\rpop：头删\\尾删，lrem listName number vlue：移除特定集合的特定值的number个 长度：llen listName 集合子集：ltrim listName start end 移动元素到新集合：rpoplpush oldlist newlist:尾删头插 替换：lset listName index newValue，将list中index位置的值替换为newValue 插入：linsert list after|before value1 value2在value1前|后插入value2 Set：无序集合 添加：sadd key value 查看所有：smembers setName 访问大小：scard setName云ield value` 获取：hget\\hmget\\hgetall\\hkeys\\hvals 删除：hdel set field 计算长度：hlen set 自增任意数：hincrby set field number Zset：有序集合，按照score排序 添加：zadd key scores values 查看：zrange key start end，zrangebyscore set min max [withscores] [limit offset count:offset表示元素下标， - count表示展示多少]，zrevrange key start end和zrange是反序的 移除：zrem zset value 访问大小：zcard zset，zcount zset min max：指定范围内元素个数 当然还存在一些特殊数据类型Geo、hyperloglog、BitMaps\n入门的话知道上面这些就好了，但redis还有很多值得深入了解的，比如： Redis事务，持久化，乐观锁，消息订阅机制，集群部署下哨兵模式，主从复制等 这些就需要大家课下去探索啦🧐\nJava中使用Redis Java有两个比较常用的Redis客户端：Lettuce 和 Jedis，前者是异步的Redis客户端，线程安全（单连接共享的方式），API更加灵活；后者是同步的Redis客户端，本身线程不安全（可以使用jedispool解决），API更加直观。 Spring中常使用Spring Data Redis为我们封装的RedisTemplate Getting Start API的使用相对比较直观且方便使用，项目实践中常常会根据业务需求封装合适的Util或者Service 快速掌握和实践也可以看黑马视频教程\n缓存策略 Cache-Aside 策略特别适合“读多”的应用场景，也是用的相对较多的缓存策略。使用 Cache Aside 策略的系统可以在一定程度上抵抗缓存故障。如果缓存服务发生故障，系统仍然可以通过直接访问数据库进行操作。但是第一次访问总是缓存不命中，这种情况还需要别的办法解决，比如可以通过缓存预热\nRead-Through 策略 这个跟 Cache-Aside 策略很类似，但是 Read-Through 逻辑上通常是由独立缓存提供程序支持，而 Cache-Aside 是直接跟数据源打交道。所以说其实就是 Cache-Aside 的封装\nWrite-Through 策略 配合 Read-Through 使用\nWrite-Behind 策略 该策略可以理解成把缓存当主要数据源，通过异步定期flush的方式持久化到数据库。不过这可能因为某些原因造成最后一次写入的数据丢失。\n缓存三兄弟 缓存穿透： 请求的数据在数据库和缓存中都不存在，这样的请求永远打到数据库上\n缓存击穿： 某个热点key缓存突然失效，导致大量请求瞬间打到数据库\n缓存雪崩： 大量key同时失效，或redis宕机，导致大量请求打到数据库\n实现功能 后面大家做项目来实现功能的时候，如果遇到以下场景，希望可以想到Redis：\n缓存（建议） 消息队列（不太建议） 延迟消息（不太建议） 排行榜（建议） 计数器（建议） 分布式ID（可以） 分布式锁（建议） 地理位置应用（建议） 分布式限流（可以） 分布式Session（建议） 布隆过滤器（建议） bitmap状态统计（可以） 共同关注（建议） 推荐关注（可以） 第二部分：了解云原生 云原生是什么 云原生的定义，业界也是“百家争鸣”各持观点，从技术视角理解云原生会相对清晰\n关键技术 微服务： 一种用于构建应用的架构方案。将一个复杂的应用拆分成多个独立自治的服务，服务与服务间通过“高内聚低耦合”的形式交互\n容器： 容器是一种打包应用的方式，可以打包应用中的所有软件和软件所依赖的环境，并可实现跨平台部署。容器关键技术：namespace命名空间，cgroup控制组 ，UnionFS联合文件系统\n容器编排： 自动化管理和协调容器的系统，专注于容器的生命周期管理和调度\n服务网格： Service Mesh 致力于解决服务间通讯的基础设施层\n不可变基础设施： 任何基础设施实例（服务器、容器等各种软硬件）一旦创建之后便成为一种只读状态，不可对其进行任何更改。如果需要修改或升级实例，唯一方式是创建一批新实例以替换\n声明式API： 可声明期望的状态，系统将不断地调整实际状态，直到与期望状态保持一致\nDevOps： 缩短开发周期，增加部署频率，更可靠地发布\nDocker核心概念 Docker官网\nImage：\n一个只读模板 由一堆只读层（read-only layer）重叠 统一文件系统（UnionFileSystem）整合成统一视角，相当于是一个root文件系统 Container：\n从面向对象角度，利用容器并通过镜像创建的相互隔离的运行实例 最上面那一层可读可写层 一个可读写的统一文件系统，加上隔离的进程空间，以及包含在其中的应用进程 Repository：\n全球最大的docker仓库 Docker Hub 集中存放镜像文件的地方 Docker Registry 可包含多个仓库（Repository），每个仓库可包含多个标签（Tag），每个标签对应一个镜像 Docker使用 Docker Engine 安装 Docker Desktop安装\nPull \u0026 Run 1 docker pull nginx:latest 1 docker run -d --name my-nginx -p 8080:80 nginx:latest Build \u0026 Push 创建项目目录 1 mkdir nginx-docker \u0026\u0026 cd nginx-docker 创建 index.html 1 2 mkdir html echo \"Welcome to SAST!\" \u003e html/index.html 创建 nginx.conf 1 2 mkdir conf vim conf/nginx.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 worker_processes 1; events { worker_connections 1024; } http { server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.html; } } } 创建 Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用官方 Nginx 基础镜像 FROM nginx:latest # 复制自定义的 Nginx 配置文件 COPY conf/nginx.conf /etc/nginx/nginx.conf # 复制 HTML 页面 COPY html/index.html /usr/share/nginx/html/index.html # 暴露 80 端口 EXPOSE 80 # 运行 Nginx CMD [\"nginx\", \"-g\", \"daemon off;\"] 构建并运行自定义 Nginx 容器 1 2 docker build -t my-nginx . docker run -d --name custom-nginx -p 8080:80 my-nginx 打 Tag 并推送到 Docker Hub （可选） 1 2 docker tag my-nginx myusername/my-nginx:latest docker push myusername/my-nginx:latest 一些别的命令 当然上面只是简单的使用示例，Docker的重点还包括，docker数据卷，docker network等\nDocker-Compose 官网安装\n只使用dockerfile进行创建镜像会有很多的问题，比如当项目部署的时候有redis，mysql这样的镜像启动顺序，或者说容器间的ip地址发生了变化，映射出错，要么生产ip写死，要么通过服务调用。因此使用docker-compose可以做到集中管理，一套带走\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 services: # 定义应用的服务 web: # 服务名称 image: nginx:latest # 使用的镜像 ports: # 定义端口映射 - \"8080:80\" # 将容器的 80 端口映射到主机的 8080 端口 volumes: # 定义卷挂载 - ./web-content:/usr/share/nginx/html # 将主机上的 ./web-content 目录挂载到容器的 /usr/share/nginx/html 目录 networks: # 定义网络 - frontend environment: # 设置环境变量 - NGINX_VERSION=latest db: image: mysql:5.7 environment: - MYSQL_ROOT_PASSWORD=root_password - MYSQL_DATABASE=my_database - MYSQL_USER=user - MYSQL_PASSWORD=password volumes: - db-data:/var/lib/mysql networks: - frontend - backend networks: # 定义网络 frontend: backend: volumes: # 定义卷 db-data: web-content: services：定义应用的各个服务，每个服务包含一个或多个容器。 image：指定服务所使用的镜像。 ports：定义端口映射，将容器内的端口映射到主机上的端口。 volumes：定义卷挂载，将主机上的目录或卷挂载到容器内。 networks：定义服务使用的网络，以及服务之间的连接关系。 environment：设置容器的环境变量。 volumes：定义卷，用于持久化数据。 编写好之后，使用docker-compose up -d 可以一次性的把需要的容器给创建好，就省去了很多麻烦\nK8S Kubernetes 是 Google 基于十多年的生产环境运维经验，开发出的一个生产级别的容器编排系统。在 Kunernetes 文档中，这样描述 Kubernetes：\n[Success] “an open-source system for automating deployment, scaling, and management of containerized appcations”.\n“一个自动化部署、可拓展和管理容器应用的开源系统”\n架构 很推荐跟着官方中文文档进行学习\nk8s中有非常多的资源对象，深入了解学习它们是为了解决什么问题，是怎么协同工作的\n学习环境 可以使用 minikube、kind 做单机学习环境，或者购买云服务器、白嫖 3个月 Google Cloud ，也可以使用电脑创建多个虚拟机或者多台电脑来搭建节点，或者使用线上学习环境等。\n作为一名后端开发,有任何问题都可以联系我，当然也欢迎与我交流技术相关的问题，感谢你的阅读🤗\n","wordCount":"620","inLanguage":"en","image":"http://localhost:1313/%3Cimage%20path/url%3E","datePublished":"2025-02-27T11:30:03Z","dateModified":"2025-02-27T11:30:03Z","author":{"@type":"Person","name":"Whitea"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/sast/2025-first-class/"},"publisher":{"@type":"Organization","name":"Whitea's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">SAST授课-入门Redis&了解云原生</h1><div class=post-description>SASTWeb组2025后端方向第一次授课</div><div class=post-meta><span title='2025-02-27 11:30:03 +0000 +0000'>February 27, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;620 words&nbsp;·&nbsp;Whitea&nbsp;|&nbsp;<a href=https://github.com/Whitea029/myblog/blob/main/content/posts/SAST/2025-first-class/index.md rel="noopener noreferrer" target=_blank>Source Code</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#第一部分redis快速入门>第一部分：Redis快速入门</a><ul><li><a href=#初步认识>初步认识</a></li><li><a href=#安装>安装</a></li><li><a href=#常用命令>常用命令</a></li><li><a href=#五大基本数据类型>五大基本数据类型</a></li><li><a href=#java中使用redis>Java中使用Redis</a></li><li><a href=#缓存策略>缓存策略</a></li><li><a href=#缓存三兄弟>缓存三兄弟</a></li><li><a href=#实现功能>实现功能</a></li></ul></li><li><a href=#第二部分了解云原生>第二部分：了解云原生</a><ul><li><a href=#云原生是什么>云原生是什么</a></li><li><a href=#关键技术>关键技术</a></li><li><a href=#docker核心概念>Docker核心概念</a></li><li><a href=#docker使用>Docker使用</a></li><li><a href=#docker-compose>Docker-Compose</a></li><li><a href=#k8s>K8S</a></li><li><a href=#架构>架构</a></li><li><a href=#学习环境>学习环境</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h1 id=入门redis--了解云原生>入门Redis & 了解云原生<a hidden class=anchor aria-hidden=true href=#入门redis--了解云原生>#</a></h1><h2 id=第一部分redis快速入门>第一部分：Redis快速入门<a hidden class=anchor aria-hidden=true href=#第一部分redis快速入门>#</a></h2><h3 id=初步认识>初步认识<a hidden class=anchor aria-hidden=true href=#初步认识>#</a></h3><p>Redis 是一个开源（BSD 许可）的，<strong>内存中的键值对（K-V）存储系统</strong>，它可以用作 数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings），散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询 bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions）和不同级别的磁盘持久化（persistence）， 并通过Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）</p><p>你得知道：</p><ul><li>Redis是Nosql型的非关系型数据库（Nosql：Not Only sql）</li><li>Redis是基于内存存储的，速度快，当然也支持数据的持久化</li><li>Redis是在处理客户端请求的时候是单线程的，在处理客户端连接时候使用IO多路复用技术</li><li>Redis其实是支持事务的，但是一次性、顺序性、排他性的执行队列中的命令，是不支持回滚的，缺乏传统ACID事务的隔离性和持久性</li></ul><h3 id=安装>安装<a hidden class=anchor aria-hidden=true href=#安装>#</a></h3><p><strong>Windows：</strong> 官方推荐使用WSL2<a href=https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-on-windows/>官网指南</a>，当然也可以在<a href=https://github.com/tporadowski/redis/releases>Github</a>上下载Zip,解压缩到本地，然后在安装目录执行<code>redis-server.exe redis.windows.conf</code>即可临时启动
<strong>Linux & Mac：</strong> 使用包管理器安装即可</p><blockquote><p>但待会我们会讲容器技术，这会让Redis的安装使用更加方便😀</p></blockquote><h3 id=常用命令>常用命令<a hidden class=anchor aria-hidden=true href=#常用命令>#</a></h3><ul><li>使用select切换数据库：<code>select [number]</code> （redis共16个数据库）</li><li>查看数据库大小：<code>DBSIZE</code></li><li>查看库内容：<code>keys *</code></li><li>判断某个值存在：<code>exists key</code></li><li>存储数据：<code>set key value</code>云</li><li>数据限时：<code>expire key number\setex key number value</code>限时多少秒后数据失效，<code>ttl key</code>查询还有多久截止</li><li>查看key类型：<code>type key</code></li><li>删除数据库：<code>flushall or flushdb DbName</code></li><li>批量插入、获取：<code>mset k1 v1 k2 v2...\mget k1 k2 k3...</code></li></ul><h3 id=五大基本数据类型>五大基本数据类型<a hidden class=anchor aria-hidden=true href=#五大基本数据类型>#</a></h3><p>不用记，用的时候查就行🤣</p><ul><li>String<ul><li>拼接key的value和value，并返回新value的长度：<code>append keyName value</code></li><li>获取字符串长度：<code>strlen key</code></li><li>对数字内容String自增、自减：<code>incr key，decr key</code></li><li>任意步长自增：<code>incrby key number</code></li><li>截取子串：<code>getrange key start end</code>（截取后包括start end所在的值，end为-1则获取所有项，java则不会包含end）</li><li>替换子串：<code>setrange key offset value</code>（从offset开始将value替换后面的内容）</li><li>如果存在则：<code>setnx key value</code></li><li>插入一个json字符串：<code>set user:1 {name:JayChou,id:1}</code></li></ul></li><li>List：所有的List命令都是l开头<ul><li>插入：<code>lpush listName value(头插法)\rpush listName value(尾插法)}</code></li><li>获取：<code>lrange listName start end，lindex listName index</code></li><li>移除：<code>lpop\rpop</code>：头删\尾删，<code>lrem listName number vlue</code>：移除特定集合的特定值的number个</li><li>长度：<code>llen listName</code></li><li>集合子集：<code>ltrim listName start end</code></li><li>移动元素到新集合：<code>rpoplpush oldlist newlist</code>:尾删头插</li><li>替换：<code>lset listName index newValue</code>，将list中index位置的值替换为newValue</li><li>插入：<code>linsert list after|before value1 value2</code>在value1前|后插入value2</li></ul></li><li>Set：无序集合<ul><li>添加：<code>sadd key value</code></li><li>查看所有：<code>smembers setName</code></li><li>访问大小：<code>scard setName</code>云ield value`</li><li>获取：<code>hget\hmget\hgetall\hkeys\hvals</code></li><li>删除：<code>hdel set field</code></li><li>计算长度：<code>hlen set</code></li><li>自增任意数：<code>hincrby set field number</code></li></ul></li><li>Zset：有序集合，按照score排序<ul><li>添加：<code>zadd key scores values</code></li><li>查看：<code>zrange key start end，zrangebyscore set min max [withscores] [limit offset count</code>:offset表示元素下标， - count表示展示多少]，zrevrange key start end和zrange是反序的</li><li>移除：<code>zrem zset value</code></li><li>访问大小：<code>zcard zset，zcount zset min max</code>：指定范围内元素个数</li></ul></li></ul><p>当然还存在一些特殊数据类型Geo、hyperloglog、BitMaps</p><blockquote><p>入门的话知道上面这些就好了，但redis还有很多值得深入了解的，比如：
Redis事务，持久化，乐观锁，消息订阅机制，集群部署下哨兵模式，主从复制等
这些就需要大家课下去探索啦🧐</p></blockquote><h3 id=java中使用redis>Java中使用Redis<a hidden class=anchor aria-hidden=true href=#java中使用redis>#</a></h3><p>Java有两个比较常用的Redis客户端：<a href=https://github.com/redis/lettuce>Lettuce</a> 和 <a href=https://github.com/redis/jedis>Jedis</a>，前者是异步的Redis客户端，线程安全（单连接共享的方式），API更加灵活；后者是同步的Redis客户端，本身线程不安全（可以使用jedispool解决），API更加直观。
Spring中常使用Spring Data Redis为我们封装的RedisTemplate <a href=https://docs.spring.io/spring-data/redis/reference/redis/getting-started.html>Getting Start</a>
API的使用相对比较直观且方便使用，项目实践中常常会根据业务需求封装合适的Util或者Service
快速掌握和实践也可以看<a href="https://www.bilibili.com/video/BV1cr4y1671t/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f6867946800a660b8bae998b1afc3fbc">黑马视频教程</a></p><h3 id=缓存策略>缓存策略<a hidden class=anchor aria-hidden=true href=#缓存策略>#</a></h3><p><img loading=lazy src=/images/2025-first-class/001.png></p><p>Cache-Aside 策略特别适合“读多”的应用场景，也是用的相对较多的缓存策略。使用 Cache Aside 策略的系统可以在一定程度上抵抗缓存故障。如果缓存服务发生故障，系统仍然可以通过直接访问数据库进行操作。但是第一次访问总是缓存不命中，这种情况还需要别的办法解决，比如可以通过缓存预热</p><ul><li>Read-Through 策略</li></ul><p><img loading=lazy src=/images/2025-first-class/002.png></p><p>这个跟 Cache-Aside 策略很类似，但是 Read-Through 逻辑上通常是由独立<strong>缓存提供程序</strong>支持，而 Cache-Aside 是直接跟数据源打交道。所以说其实就是 Cache-Aside 的封装</p><ul><li>Write-Through 策略</li></ul><p><img loading=lazy src=/images/2025-first-class/003.png></p><p>配合 Read-Through 使用</p><ul><li>Write-Behind 策略</li></ul><p><img loading=lazy src=/images/2025-first-class/004.png></p><p>该策略可以理解成把缓存当主要数据源，通过异步定期flush的方式持久化到数据库。不过这可能因为某些原因造成最后一次写入的数据丢失。</p><h3 id=缓存三兄弟>缓存三兄弟<a hidden class=anchor aria-hidden=true href=#缓存三兄弟>#</a></h3><p><strong>缓存穿透：</strong> 请求的数据在数据库和缓存中都不存在，这样的请求永远打到数据库上</p><p><strong>缓存击穿：</strong> 某个热点key缓存突然失效，导致大量请求瞬间打到数据库</p><p><strong>缓存雪崩：</strong> 大量key同时失效，或redis宕机，导致大量请求打到数据库</p><h3 id=实现功能>实现功能<a hidden class=anchor aria-hidden=true href=#实现功能>#</a></h3><p>后面大家做项目来实现功能的时候，如果遇到以下场景，希望可以想到Redis：</p><ul><li>缓存（建议）</li><li>消息队列（不太建议）</li><li>延迟消息（不太建议）</li><li>排行榜（建议）</li><li>计数器（建议）</li><li>分布式ID（可以）</li><li>分布式锁（建议）</li><li>地理位置应用（建议）</li><li>分布式限流（可以）</li><li>分布式Session（建议）</li><li>布隆过滤器（建议）</li><li>bitmap状态统计（可以）</li><li>共同关注（建议）</li><li>推荐关注（可以）</li></ul><h2 id=第二部分了解云原生>第二部分：了解云原生<a hidden class=anchor aria-hidden=true href=#第二部分了解云原生>#</a></h2><h3 id=云原生是什么>云原生是什么<a hidden class=anchor aria-hidden=true href=#云原生是什么>#</a></h3><p><img loading=lazy src=/images/2025-first-class/005.png></p><p>云原生的定义，业界也是“百家争鸣”各持观点，从技术视角理解云原生会相对清晰</p><p><img loading=lazy src=/images/2025-first-class/006.png></p><h3 id=关键技术>关键技术<a hidden class=anchor aria-hidden=true href=#关键技术>#</a></h3><p><strong>微服务：</strong> 一种用于构建应用的架构方案。将一个复杂的应用拆分成多个独立自治的服务，服务与服务间通过“高内聚低耦合”的形式交互</p><p><strong>容器：</strong> 容器是一种打包应用的方式，可以打包应用中的所有软件和软件所依赖的环境，并可实现跨平台部署。容器关键技术：namespace命名空间，cgroup控制组 ，UnionFS联合文件系统</p><p><strong>容器编排：</strong> 自动化管理和协调容器的系统，专注于容器的生命周期管理和调度</p><p><strong>服务网格：</strong> Service Mesh 致力于解决服务间通讯的基础设施层</p><p><strong>不可变基础设施：</strong> 任何基础设施实例（服务器、容器等各种软硬件）一旦创建之后便成为一种只读状态，不可对其进行任何更改。如果需要修改或升级实例，唯一方式是创建一批新实例以替换</p><p><strong>声明式API：</strong> 可声明期望的状态，系统将不断地调整实际状态，直到与期望状态保持一致</p><p><strong>DevOps：</strong> 缩短开发周期，增加部署频率，更可靠地发布</p><p><img loading=lazy src=/images/2025-first-class/007.png></p><h3 id=docker核心概念>Docker核心概念<a hidden class=anchor aria-hidden=true href=#docker核心概念>#</a></h3><p><a href=https://docs.docker.com/>Docker官网</a></p><p><strong>Image：</strong></p><ul><li>一个只读模板</li><li>由一堆只读层（read-only layer）重叠</li><li>统一文件系统（UnionFileSystem）整合成统一视角，相当于是一个root文件系统</li></ul><p><strong>Container：</strong></p><ul><li>从面向对象角度，利用容器并通过镜像创建的相互隔离的运行实例</li><li>最上面那一层可读可写层</li><li>一个可读写的统一文件系统，加上隔离的进程空间，以及包含在其中的应用进程</li></ul><p><strong>Repository：</strong></p><ul><li>全球最大的docker仓库 <a href=https://hub.docker.com/>Docker Hub</a></li><li>集中存放镜像文件的地方</li><li>Docker Registry 可包含多个仓库（Repository），每个仓库可包含多个标签（Tag），每个标签对应一个镜像</li></ul><h3 id=docker使用>Docker使用<a hidden class=anchor aria-hidden=true href=#docker使用>#</a></h3><p><a href=https://docs.docker.com/engine/install/>Docker Engine 安装</a>
<a href=https://docs.docker.com/desktop/>Docker Desktop安装</a></p><h4 id=pull--run>Pull & Run<a hidden class=anchor aria-hidden=true href=#pull--run>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker pull nginx:latest
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -d --name my-nginx -p 8080:80 nginx:latest
</span></span></code></pre></td></tr></table></div></div><h4 id=build--push>Build & Push<a hidden class=anchor aria-hidden=true href=#build--push>#</a></h4><ol><li>创建项目目录</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir nginx-docker <span class=o>&amp;&amp;</span> <span class=nb>cd</span> nginx-docker
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>创建 index.html</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-3-1><a class=lnlinks href=#hl-3-1>1</a>
</span><span class=lnt id=hl-3-2><a class=lnlinks href=#hl-3-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir html
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;&lt;h1&gt;Welcome to SAST!&lt;/h1&gt;&#34;</span> &gt; html/index.html
</span></span></code></pre></td></tr></table></div></div><ol start=3><li>创建 nginx.conf</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-4-1><a class=lnlinks href=#hl-4-1>1</a>
</span><span class=lnt id=hl-4-2><a class=lnlinks href=#hl-4-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir conf
</span></span><span class=line><span class=cl>vim conf/nginx.conf
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-5-1><a class=lnlinks href=#hl-5-1> 1</a>
</span><span class=lnt id=hl-5-2><a class=lnlinks href=#hl-5-2> 2</a>
</span><span class=lnt id=hl-5-3><a class=lnlinks href=#hl-5-3> 3</a>
</span><span class=lnt id=hl-5-4><a class=lnlinks href=#hl-5-4> 4</a>
</span><span class=lnt id=hl-5-5><a class=lnlinks href=#hl-5-5> 5</a>
</span><span class=lnt id=hl-5-6><a class=lnlinks href=#hl-5-6> 6</a>
</span><span class=lnt id=hl-5-7><a class=lnlinks href=#hl-5-7> 7</a>
</span><span class=lnt id=hl-5-8><a class=lnlinks href=#hl-5-8> 8</a>
</span><span class=lnt id=hl-5-9><a class=lnlinks href=#hl-5-9> 9</a>
</span><span class=lnt id=hl-5-10><a class=lnlinks href=#hl-5-10>10</a>
</span><span class=lnt id=hl-5-11><a class=lnlinks href=#hl-5-11>11</a>
</span><span class=lnt id=hl-5-12><a class=lnlinks href=#hl-5-12>12</a>
</span><span class=lnt id=hl-5-13><a class=lnlinks href=#hl-5-13>13</a>
</span><span class=lnt id=hl-5-14><a class=lnlinks href=#hl-5-14>14</a>
</span><span class=lnt id=hl-5-15><a class=lnlinks href=#hl-5-15>15</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-nginx data-lang=nginx><span class=line><span class=cl><span class=k>worker_processes</span>  <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>events</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kn>worker_connections</span> <span class=mi>1024</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>http</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kn>server</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kn>listen</span> <span class=mi>80</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kn>server_name</span> <span class=s>localhost</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kn>location</span> <span class=s>/</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kn>root</span> <span class=s>/usr/share/nginx/html</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kn>index</span> <span class=s>index.html</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ol start=4><li>创建 Dockerfile</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-6-1><a class=lnlinks href=#hl-6-1> 1</a>
</span><span class=lnt id=hl-6-2><a class=lnlinks href=#hl-6-2> 2</a>
</span><span class=lnt id=hl-6-3><a class=lnlinks href=#hl-6-3> 3</a>
</span><span class=lnt id=hl-6-4><a class=lnlinks href=#hl-6-4> 4</a>
</span><span class=lnt id=hl-6-5><a class=lnlinks href=#hl-6-5> 5</a>
</span><span class=lnt id=hl-6-6><a class=lnlinks href=#hl-6-6> 6</a>
</span><span class=lnt id=hl-6-7><a class=lnlinks href=#hl-6-7> 7</a>
</span><span class=lnt id=hl-6-8><a class=lnlinks href=#hl-6-8> 8</a>
</span><span class=lnt id=hl-6-9><a class=lnlinks href=#hl-6-9> 9</a>
</span><span class=lnt id=hl-6-10><a class=lnlinks href=#hl-6-10>10</a>
</span><span class=lnt id=hl-6-11><a class=lnlinks href=#hl-6-11>11</a>
</span><span class=lnt id=hl-6-12><a class=lnlinks href=#hl-6-12>12</a>
</span><span class=lnt id=hl-6-13><a class=lnlinks href=#hl-6-13>13</a>
</span><span class=lnt id=hl-6-14><a class=lnlinks href=#hl-6-14>14</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># 使用官方 Nginx 基础镜像</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> nginx:latest</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 复制自定义的 Nginx 配置文件</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> conf/nginx.conf /etc/nginx/nginx.conf<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 复制 HTML 页面</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> html/index.html /usr/share/nginx/html/index.html<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 暴露 80 端口</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 80</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 运行 Nginx</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;nginx&#34;</span><span class=p>,</span> <span class=s2>&#34;-g&#34;</span><span class=p>,</span> <span class=s2>&#34;daemon off;&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><ol start=5><li>构建并运行自定义 Nginx 容器</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-7-1><a class=lnlinks href=#hl-7-1>1</a>
</span><span class=lnt id=hl-7-2><a class=lnlinks href=#hl-7-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker build -t my-nginx .
</span></span><span class=line><span class=cl>docker run -d --name custom-nginx -p 8080:80 my-nginx
</span></span></code></pre></td></tr></table></div></div><ol start=6><li>打 Tag 并推送到 Docker Hub （可选）</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-8-1><a class=lnlinks href=#hl-8-1>1</a>
</span><span class=lnt id=hl-8-2><a class=lnlinks href=#hl-8-2>2</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker tag my-nginx myusername/my-nginx:latest
</span></span><span class=line><span class=cl>docker push myusername/my-nginx:latest
</span></span></code></pre></td></tr></table></div></div><p><a href=https://cloud.tencent.com/developer/article/1772136>一些别的命令</a>
当然上面只是简单的使用示例，Docker的重点还包括，<strong>docker数据卷，docker network</strong>等</p><h3 id=docker-compose>Docker-Compose<a hidden class=anchor aria-hidden=true href=#docker-compose>#</a></h3><p><a href=https://docs.docker.com/compose/install/>官网安装</a></p><p>只使用dockerfile进行创建镜像会有很多的问题，比如当项目部署的时候有redis，mysql这样的镜像启动顺序，或者说容器间的ip地址发生了变化，映射出错，要么生产ip写死，要么通过服务调用。因此使用docker-compose可以做到集中管理，一套带走</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-9-1><a class=lnlinks href=#hl-9-1> 1</a>
</span><span class=lnt id=hl-9-2><a class=lnlinks href=#hl-9-2> 2</a>
</span><span class=lnt id=hl-9-3><a class=lnlinks href=#hl-9-3> 3</a>
</span><span class=lnt id=hl-9-4><a class=lnlinks href=#hl-9-4> 4</a>
</span><span class=lnt id=hl-9-5><a class=lnlinks href=#hl-9-5> 5</a>
</span><span class=lnt id=hl-9-6><a class=lnlinks href=#hl-9-6> 6</a>
</span><span class=lnt id=hl-9-7><a class=lnlinks href=#hl-9-7> 7</a>
</span><span class=lnt id=hl-9-8><a class=lnlinks href=#hl-9-8> 8</a>
</span><span class=lnt id=hl-9-9><a class=lnlinks href=#hl-9-9> 9</a>
</span><span class=lnt id=hl-9-10><a class=lnlinks href=#hl-9-10>10</a>
</span><span class=lnt id=hl-9-11><a class=lnlinks href=#hl-9-11>11</a>
</span><span class=lnt id=hl-9-12><a class=lnlinks href=#hl-9-12>12</a>
</span><span class=lnt id=hl-9-13><a class=lnlinks href=#hl-9-13>13</a>
</span><span class=lnt id=hl-9-14><a class=lnlinks href=#hl-9-14>14</a>
</span><span class=lnt id=hl-9-15><a class=lnlinks href=#hl-9-15>15</a>
</span><span class=lnt id=hl-9-16><a class=lnlinks href=#hl-9-16>16</a>
</span><span class=lnt id=hl-9-17><a class=lnlinks href=#hl-9-17>17</a>
</span><span class=lnt id=hl-9-18><a class=lnlinks href=#hl-9-18>18</a>
</span><span class=lnt id=hl-9-19><a class=lnlinks href=#hl-9-19>19</a>
</span><span class=lnt id=hl-9-20><a class=lnlinks href=#hl-9-20>20</a>
</span><span class=lnt id=hl-9-21><a class=lnlinks href=#hl-9-21>21</a>
</span><span class=lnt id=hl-9-22><a class=lnlinks href=#hl-9-22>22</a>
</span><span class=lnt id=hl-9-23><a class=lnlinks href=#hl-9-23>23</a>
</span><span class=lnt id=hl-9-24><a class=lnlinks href=#hl-9-24>24</a>
</span><span class=lnt id=hl-9-25><a class=lnlinks href=#hl-9-25>25</a>
</span><span class=lnt id=hl-9-26><a class=lnlinks href=#hl-9-26>26</a>
</span><span class=lnt id=hl-9-27><a class=lnlinks href=#hl-9-27>27</a>
</span><span class=lnt id=hl-9-28><a class=lnlinks href=#hl-9-28>28</a>
</span><span class=lnt id=hl-9-29><a class=lnlinks href=#hl-9-29>29</a>
</span><span class=lnt id=hl-9-30><a class=lnlinks href=#hl-9-30>30</a>
</span><span class=lnt id=hl-9-31><a class=lnlinks href=#hl-9-31>31</a>
</span><span class=lnt id=hl-9-32><a class=lnlinks href=#hl-9-32>32</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>services</span><span class=p>:</span><span class=w>  </span><span class=c># 定义应用的服务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>web</span><span class=p>:</span><span class=w>  </span><span class=c># 服务名称</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>nginx:latest </span><span class=w> </span><span class=c># 使用的镜像</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>  </span><span class=c># 定义端口映射</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;8080:80&#34;</span><span class=w>  </span><span class=c># 将容器的 80 端口映射到主机的 8080 端口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>  </span><span class=c># 定义卷挂载</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>./web-content:/usr/share/nginx/html </span><span class=w> </span><span class=c># 将主机上的 ./web-content 目录挂载到容器的 /usr/share/nginx/html 目录</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>networks</span><span class=p>:</span><span class=w>  </span><span class=c># 定义网络</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>frontend</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>environment</span><span class=p>:</span><span class=w>  </span><span class=c># 设置环境变量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>NGINX_VERSION=latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>db</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>mysql:5.7</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>environment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>MYSQL_ROOT_PASSWORD=root_password</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>MYSQL_DATABASE=my_database</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>MYSQL_USER=user</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>MYSQL_PASSWORD=password</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>db-data:/var/lib/mysql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>networks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>frontend</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>backend</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>networks</span><span class=p>:</span><span class=w>  </span><span class=c># 定义网络</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>frontend</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>backend</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>volumes</span><span class=p>:</span><span class=w>  </span><span class=c># 定义卷</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>db-data</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>web-content</span><span class=p>:</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li><code>services</code>：定义应用的各个服务，每个服务包含一个或多个容器。</li><li><code>image</code>：指定服务所使用的镜像。</li><li><code>ports</code>：定义端口映射，将容器内的端口映射到主机上的端口。</li><li><code>volumes</code>：定义卷挂载，将主机上的目录或卷挂载到容器内。</li><li><code>networks</code>：定义服务使用的网络，以及服务之间的连接关系。</li><li><code>environment</code>：设置容器的环境变量。</li><li><code>volumes</code>：定义卷，用于持久化数据。</li></ul><p>编写好之后，使用docker-compose up -d 可以一次性的把需要的容器给创建好，就省去了很多麻烦</p><h3 id=k8s>K8S<a hidden class=anchor aria-hidden=true href=#k8s>#</a></h3><p>Kubernetes 是 Google 基于十多年的生产环境运维经验，开发出的一个生产级别的容器编排系统。在 Kunernetes 文档中，这样描述 Kubernetes：</p><blockquote><p>[Success]
&ldquo;an open-source system for automating deployment, scaling, and management of containerized appcations&rdquo;.<br>“一个自动化部署、可拓展和管理容器应用的开源系统”</p></blockquote><h3 id=架构>架构<a hidden class=anchor aria-hidden=true href=#架构>#</a></h3><p>很推荐跟着官方<a href=https://kubernetes.io/zh-cn/docs/concepts/architecture/>中文文档</a>进行学习</p><p><img loading=lazy src=/images/2025-first-class/008.svg></p><p>k8s中有非常多的资源对象，深入了解学习它们是为了解决什么问题，是怎么协同工作的</p><h3 id=学习环境>学习环境<a hidden class=anchor aria-hidden=true href=#学习环境>#</a></h3><p>可以使用 minikube、kind 做单机学习环境，或者购买云服务器、白嫖 3个月 Google Cloud ，也可以使用电脑创建多个虚拟机或者多台电脑来搭建节点，或者使用线上学习环境等。</p><blockquote><p>作为一名后端开发,有任何问题都可以联系我，当然也欢迎与我交流技术相关的问题，感谢你的阅读🤗</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/sast/>SAST</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/sast/2025-second-class/><span class=title>« Prev</span><br><span>SAST授课-从HTTP到RPC & 服务发现与注册</span>
</a><a class=next href=http://localhost:1313/posts/sast/get-start-with-spring-boot/><span class=title>Next »</span><br><span>SAST授课-SpringBoot入门</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Whitea's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>