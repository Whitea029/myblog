<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OTel可观测性 | Whitea's Blog</title>
<meta name=keywords content="Distributed,SAST"><meta name=description content="2025 SAST.Web第五次授课"><meta name=author content="Whitea"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://whitea029.github.io/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://whitea029.github.io/images/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://whitea029.github.io/images/favicon-32x32.png><link rel=apple-touch-icon href=https://whitea029.github.io/images/apple-touch-icon.png><link rel=mask-icon href=https://whitea029.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://whitea029.github.io/posts/distributed/observability/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://whitea029.github.io/posts/distributed/observability/"><meta property="og:site_name" content="Whitea's Blog"><meta property="og:title" content="OTel可观测性"><meta property="og:description" content="2025 SAST.Web第五次授课"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-08T11:30:03+00:00"><meta property="article:modified_time" content="2025-03-08T11:30:03+00:00"><meta property="article:tag" content="Distributed"><meta property="article:tag" content="SAST"><meta property="og:image" content="https://whitea029.github.io/%3Cimage%20path/url%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://whitea029.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="OTel可观测性"><meta name=twitter:description content="2025 SAST.Web第五次授课"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://whitea029.github.io/posts/"},{"@type":"ListItem","position":2,"name":"OTel可观测性","item":"https://whitea029.github.io/posts/distributed/observability/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OTel可观测性","name":"OTel可观测性","description":"2025 SAST.Web第五次授课","keywords":["Distributed","SAST"],"articleBody":"可观测性 什么是可观测性？ 马克·安德森（Marc Andreessen）说过这样一句话：“软件正在吞噬世界 ”。这句话发表于2011年，但是十多年后的今天，我想它更好的演绎应该是“云原生正在吞噬世界，万物皆可上云”。面对云原生这个新赛道，BAT、美团、字节跳动、快手等一线大厂都在加速推进业务的容器化、云原生化。\n也正是由于各大厂商对云原生的奔赴，传统的技术架构面临着巨大的冲击，我们的监控对象也由传统的单体结构，变成了分布式的多个微服务。监控，被架到了一个不得不革自己命的位置。在这样的背景之下，可观测性（Observability）脱颖而出。\nCNCF 早在定义云原生的概念时就提到了可观测性 ，它声称可观测性是云原生时代的必备能力。而随着可观测性的概念明晰化，相关产品纷纷涌现，“可观测性”越来越成为云原生一个绕不开的话题。\n在计算机系统和软件领域，可观测性的含义：它可以从系统和应用对外输出的信息（包括你可能已经知道的指标、日志和链路），来帮助我们了解应用程序的内部系统状态和运行情况。\n可观测性能够架起开发人员和运维人员构建合作的桥梁，运维人员使用可观测性来发现问题，给故障现场提供足够的数据让开发人员进行分析，而开发人员可以使用可观测性来指导运维人员定位问题，并使用工具来质疑和验证假设；\n从单机电脑时代的Windows任务管理器，Linux一堆Top、PS等命令帮助我们知道操作系统的运行转台；再到局域网时代的C/S架构、互联网时代的B/S架构的网络监控工具；再到如今移动互联网时代，出现了大量的可观测性技术。ELK方案、基于时序数据库的监控软件（如Prometheus、Telegraf + InfluxDB 等，APM 则出现了 ZipKin、Jaeger、Pinpoint、Skywalking 这些软件）然而，如果我们要完整地“观测”一个互联网系统，还是需要将各种形态的开源监控产品组合起来使用。\nOpenTelemetry 这个组织的出现标志着业界意识的产生，也就是，我们需要将系统的可观测性变成一种统一的标准和规范。OpenTelemetry 致力于推动更多的应用和服务遵循这一规范，同时也会提供相应的可观测性能力。这也是我们今天这节课的重点\nMetrics\n指标 是对一段时间内基础设施或应用程序的数值数据的汇总。由于指标最大的特点是聚合性，它生成的数值反映了预定义时间段内系统状态的汇总报告，在此期间处于活动状态的所有请求的行为都会汇总为一个数值，因此缺乏细颗粒度。同时这些指标很可能都是彼此不相关的，没有关联性。\nLog\n日志 是一种带时间戳的文本记录，可以是结构化，也可以是非结构化的。\n结构化日志\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { \"timestamp\": \"2024-08-04T12:34:56.789Z\", \"level\": \"INFO\", \"service\": \"user-authentication\", \"environment\": \"production\", \"message\": \"User login successful\", \"context\": { \"userId\": \"12345\", \"username\": \"johndoe\", \"ipAddress\": \"192.168.1.1\", \"userAgent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\" }, \"transactionId\": \"abcd-efgh-ijkl-mnop\", \"duration\": 200, \"request\": { \"method\": \"POST\", \"url\": \"/api/v1/login\", \"headers\": { \"Content-Type\": \"application/json\", \"Accept\": \"application/json\" }, \"body\": { \"username\": \"johndoe\", \"password\": \"******\" } }, \"response\": { \"statusCode\": 200, \"body\": { \"success\": true, \"token\": \"jwt-token-here\" } } } 非结构化日志\n1 2 3 4 5 [ERROR] 2024-08-04 12:45:23 - Failed to connect to database. Exception: java.sql.SQLException: Timeout expired. Attempted reconnect 3 times. Server: db.example.com, Port: 5432 System reboot initiated at 2024-08-04 03:00:00 by user: admin. Reason: Scheduled maintenance. Services stopped: web-server, database, cache. Estimated downtime: 15 minutes. DEBUG - 2024-08-04 09:30:15 - User johndoe performed action: file_upload. Filename: report_Q3_2024.pdf, Size: 2.3 MB, Duration: 5.2 seconds. Result: Success Trace\n链路 是请求经过应用程序的路径。可以从一个宏观的角度看到请求在应用内的路径。链路追踪检测的主要问题是，如果仅靠开发人员“插桩”（英文 Instrument，有些地方也翻译成埋点，是指将有关系统状态的数据发送到监测系统）他们的代码是不够的。大量应用程序是使用可能需要额外工具的开源框架或库构建的。这在多语言架构的地方变得更加具有挑战性，因为要考虑到每种语言、框架和协议的不同。同时，增加插桩的成本也是比较高的，很难真正做到全面覆盖。另一方面大量的插桩也会占用比较高的计算资源。\nOpenTelementry https://opentelemetry.io/docs/what-is-opentelemetry/\nOpenTelemetry 简称 OTel， 是 CNCF （ Cloud Native Computing Foundation，云原生计算基金会，是一个开源软件基金会，致力于云原生技术的普及和可持续发展） 的一个可观测性项目。\nOpenTelemetry 旨在提供可观测性领域的标准化方案，解决遥测数据的数据建模、采集、处理、导出等标准化问题，并能够将这些数据发送到你选择的后端（开源或商业均可）。这样你就可以建立不被供应商锁定的可观测，灵活地更改后端，不需要再次更改代码，重新进行插桩（Instrument）了\nOpenTelemetry 不是凭空出现的。在 OpenTelemetry 出现之前，还出现过 OpenTracing 和 OpenCensus 两套标准。\nOTel 架构 跨语言实现（Specification） API/SDK 接受、转换和导出遥测数据的工具（Opentelemetry Collector） 跨语言规范\n跨语言规范描述了所有实现的跨语言要求和数据模型，包括遥测客户端内部实现所需要的标准和定义，也包含与外部通信时需要实现的协议规范。跨语言规范主要包含了下面几类。\nAPI：定义用于生成和关联追踪、指标和日志的数据类型和操作。 SDK：定义 API 特定语言实现的要求，同时还定义配置、数据处理和导出等概念。 数据：定义遥测后端可以提供支持的 OpenTelemetry 协议 （OTLP） 和与供应商无关的语义约定。 这里要重点说一下这个 OTLP 协议，它的全称是 OpenTelemetry Protocol，它是 OpenTelemetry 原生的遥测信号传递协议，虽然 OpenTelemetry 项目组件支持了Zipkin v2 或 Jaeger Thrift 协议格式的实现，但这种支持都是以第三方贡献库的形式提供的。只有 OTLP 是 OpenTelemetry 官方原生支持的格式。OTLP 的数据模型定义是基于 ProtoBuf 完成的，如果你需要实现一套可以收集 OTLP 遥测数据的后端服务，那就需要了解里面的内容（可以参考代码仓库 opentelemetry-proto）。\nAPI / SDK\nAPI 可以让开发者对应用程序代码进行插桩（Instrument），而 SDK 是 API 的具体实现，是和开发语言相关的。\nhttps://opentelemetry.io/docs/concepts/instrumentation/\n主要有两种方式实现插桩\nCode-based solutions via official APIs and SDKs for most languages Zero-code solutions 前者是使用OTel API为你的应用手动插桩监控，是零代码解决方案的重要补充 后者则是使用OTel为各种语言和库开发的SDK、OpenTelemetry 公共组件的设计模式或语言特性等来降低使用门槛。\nOpenTelemetry Collector\nCollector应该是OTel架构中最重要的部分\nhttps://opentelemetry.io/docs/collector/\nVendor-agnostic way to receive, process and export telemetry data.\nCollector 针对如何接收、处理和导出遥测数据提供了与供应商无关的实现，消除了运行、操作和维护多个代理/收集器的需要，它支持将开源可观测性数据格式（例如 Jaeger、Prometheus 等）发送到一个或多个开源或商业后端。\n在 Collector 的内部，有一套负责接收、处理和导出数据的流程被称为 Pipeline。 每个 Pipeline 由下面三部分组件组合而成。\nReceiever: 负责按照对应的协议格式监听和接收遥测数据，并把数据转给一个或多个Processor Processor：负责加工处理遥测数据，如丢弃数据，增加信息，转发处理等，并把数据传递给下一个Processor或者一个或多个Exporter Exporter：负责把数据传递给下一个接收端，比如将指标数据存储在Prometheus中 部署角度\n从部署的角度而言，Collector有下面两种模式\n第一种模式可以统称为Agent模式。 它是把 Collector 部署在应用程序所在的主机内部（在 Kubernetes 环境中，可以使用 DaemonSet），或者在 K8s 环境中通过边车（Sidecar）的方式部署。这样，应用采集到的遥测数据可以直接传递给 Collector。\n第二种是Gateway模式。 它把 Collector 当作一个独立的中间件，应用会把采集到的遥测数据往这个中间件里传递。\nOTel技术方案 针对 OTel 有很多不同的技术实现方案，我们可以分别了解一下\nOTel to 开源工具组合\nhttps://docs.guance.com/best-practices/cloud-native/opentelemetry-elk/\n作为经典的遥测数据的处理架构，我们可以使用不同的开源工具将不同的遥测数据存储在不同的平台。比如log我们可以存储在ELK中，traces我们可以存储在Jeager中，而matrics可以保存在Promethues中并通过Grafana展示\nOTel to Grafana\nhttps://docs.guance.com/best-practices/cloud-native/opentelemetry-grafana/\n随着 Grafana 进军可观测行业，Grafana的 Tempo 和 Loki 逐渐被很多人使用\nGrafana Tempo 一个开源易使用且大规模的分布式链路追踪后端。不依赖数据库或搜索引擎（如 Elasticsearch），直接把 trace 存到对象存储（比如 S3/MinIO），可横向扩展，超高性价比。\nLoki 是 Grafana Labs 团队最新的开源项目，是一个水平可扩展，高可用性，多租户的日志聚合系统。相比于ELK的日志处理方案，Loki的设计是十分经济高效的，并不会建立全文索引，而是对数据进行Tag标注，类似于 Promethues，官方给的介绍就是 “Like Prometheus, but for logs”，非常适合云原生的场景。常常搭配 Promtail 使用。\nOTel to 观测云平台\n阿里云、腾讯云、观测云等国内的云平台都提供了云可观测的解决方案，像国外也有ELK Stack、AWS CloudWatch、Grafana Labs等\n","wordCount":"389","inLanguage":"en","image":"https://whitea029.github.io/%3Cimage%20path/url%3E","datePublished":"2025-03-08T11:30:03Z","dateModified":"2025-03-08T11:30:03Z","author":{"@type":"Person","name":"Whitea"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://whitea029.github.io/posts/distributed/observability/"},"publisher":{"@type":"Organization","name":"Whitea's Blog","logo":{"@type":"ImageObject","url":"https://whitea029.github.io/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://whitea029.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://whitea029.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://whitea029.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://whitea029.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://whitea029.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://whitea029.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">OTel可观测性</h1><div class=post-description>2025 SAST.Web第五次授课</div><div class=post-meta><span title='2025-03-08 11:30:03 +0000 +0000'>March 8, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;389 words&nbsp;·&nbsp;Whitea&nbsp;|&nbsp;<a href=https://github.com/Whitea029/myblog/blob/main/content/posts/distributed/observability/index.md rel="noopener noreferrer" target=_blank>Source Code</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#可观测性>可观测性</a><ul><li><a href=#什么是可观测性>什么是可观测性？</a></li><li><a href=#opentelementry>OpenTelementry</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=可观测性>可观测性<a hidden class=anchor aria-hidden=true href=#可观测性>#</a></h2><h3 id=什么是可观测性>什么是可观测性？<a hidden class=anchor aria-hidden=true href=#什么是可观测性>#</a></h3><blockquote><p>马克·安德森（Marc Andreessen）说过这样一句话：“软件正在吞噬世界 ”。这句话发表于2011年，但是十多年后的今天，我想它更好的演绎应该是“云原生正在吞噬世界，万物皆可上云”。面对云原生这个新赛道，BAT、美团、字节跳动、快手等一线大厂都在加速推进业务的容器化、云原生化。</p></blockquote><blockquote><p>也正是由于各大厂商对云原生的奔赴，传统的技术架构面临着巨大的冲击，我们的监控对象也由传统的单体结构，变成了分布式的多个微服务。监控，被架到了一个不得不革自己命的位置。在这样的背景之下，可观测性（Observability）脱颖而出。</p></blockquote><blockquote><p>CNCF 早在定义云原生的概念时就提到了可观测性 ，它声称可观测性是云原生时代的必备能力。而随着可观测性的概念明晰化，相关产品纷纷涌现，“可观测性”越来越成为云原生一个绕不开的话题。</p></blockquote><p>在计算机系统和软件领域，可观测性的含义：它可以从系统和应用对外输出的信息（包括你可能已经知道的指标、日志和链路），来帮助我们了解应用程序的内部系统状态和运行情况。</p><p><img loading=lazy src=/posts/distributed/observability/001.png></p><p><strong>可观测性能够架起开发人员和运维人员构建合作的桥梁</strong>，运维人员使用可观测性来发现问题，给故障现场提供足够的数据让开发人员进行分析，而开发人员可以使用可观测性来指导运维人员定位问题，并使用工具来质疑和验证假设；</p><p>从单机电脑时代的Windows任务管理器，Linux一堆Top、PS等命令帮助我们知道操作系统的运行转台；再到局域网时代的C/S架构、互联网时代的B/S架构的网络监控工具；再到如今移动互联网时代，出现了大量的可观测性技术。ELK方案、基于时序数据库的监控软件（如Prometheus、Telegraf + InfluxDB 等，APM 则出现了 ZipKin、Jaeger、Pinpoint、Skywalking 这些软件）然而，如果我们要完整地“观测”一个互联网系统，还是需要将各种形态的开源监控产品组合起来使用。</p><p>OpenTelemetry 这个组织的出现标志着业界意识的产生，也就是，我们需要将系统的可观测性变成一种统一的标准和规范。OpenTelemetry 致力于推动更多的应用和服务遵循这一规范，同时也会提供相应的可观测性能力。这也是我们今天这节课的重点</p><p><strong>Metrics</strong></p><p>指标 是对一段时间内基础设施或应用程序的数值数据的汇总。由于指标最大的特点是聚合性，它生成的数值反映了预定义时间段内系统状态的汇总报告，在此期间处于活动状态的所有请求的行为都会汇总为一个数值，因此缺乏细颗粒度。同时这些指标很可能都是彼此不相关的，没有关联性。</p><p><strong>Log</strong></p><p>日志 是一种带时间戳的文本记录，可以是结构化，也可以是非结构化的。</p><p>结构化日志</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span><span class=lnt id=hl-0-21><a class=lnlinks href=#hl-0-21>21</a>
</span><span class=lnt id=hl-0-22><a class=lnlinks href=#hl-0-22>22</a>
</span><span class=lnt id=hl-0-23><a class=lnlinks href=#hl-0-23>23</a>
</span><span class=lnt id=hl-0-24><a class=lnlinks href=#hl-0-24>24</a>
</span><span class=lnt id=hl-0-25><a class=lnlinks href=#hl-0-25>25</a>
</span><span class=lnt id=hl-0-26><a class=lnlinks href=#hl-0-26>26</a>
</span><span class=lnt id=hl-0-27><a class=lnlinks href=#hl-0-27>27</a>
</span><span class=lnt id=hl-0-28><a class=lnlinks href=#hl-0-28>28</a>
</span><span class=lnt id=hl-0-29><a class=lnlinks href=#hl-0-29>29</a>
</span><span class=lnt id=hl-0-30><a class=lnlinks href=#hl-0-30>30</a>
</span><span class=lnt id=hl-0-31><a class=lnlinks href=#hl-0-31>31</a>
</span><span class=lnt id=hl-0-32><a class=lnlinks href=#hl-0-32>32</a>
</span><span class=lnt id=hl-0-33><a class=lnlinks href=#hl-0-33>33</a>
</span><span class=lnt id=hl-0-34><a class=lnlinks href=#hl-0-34>34</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;timestamp&#34;</span><span class=p>:</span> <span class=s2>&#34;2024-08-04T12:34:56.789Z&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;level&#34;</span><span class=p>:</span> <span class=s2>&#34;INFO&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;service&#34;</span><span class=p>:</span> <span class=s2>&#34;user-authentication&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;environment&#34;</span><span class=p>:</span> <span class=s2>&#34;production&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;message&#34;</span><span class=p>:</span> <span class=s2>&#34;User login successful&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;context&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;userId&#34;</span><span class=p>:</span> <span class=s2>&#34;12345&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;username&#34;</span><span class=p>:</span> <span class=s2>&#34;johndoe&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;ipAddress&#34;</span><span class=p>:</span> <span class=s2>&#34;192.168.1.1&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;userAgent&#34;</span><span class=p>:</span> <span class=s2>&#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;transactionId&#34;</span><span class=p>:</span> <span class=s2>&#34;abcd-efgh-ijkl-mnop&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;duration&#34;</span><span class=p>:</span> <span class=mi>200</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;request&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;method&#34;</span><span class=p>:</span> <span class=s2>&#34;POST&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;url&#34;</span><span class=p>:</span> <span class=s2>&#34;/api/v1/login&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;headers&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;Content-Type&#34;</span><span class=p>:</span> <span class=s2>&#34;application/json&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;Accept&#34;</span><span class=p>:</span> <span class=s2>&#34;application/json&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;body&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;username&#34;</span><span class=p>:</span> <span class=s2>&#34;johndoe&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;password&#34;</span><span class=p>:</span> <span class=s2>&#34;******&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>},</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;response&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;statusCode&#34;</span><span class=p>:</span> <span class=mi>200</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;body&#34;</span><span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;success&#34;</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;token&#34;</span><span class=p>:</span> <span class=s2>&#34;jwt-token-here&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>非结构化日志</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span><span class=lnt id=hl-1-2><a class=lnlinks href=#hl-1-2>2</a>
</span><span class=lnt id=hl-1-3><a class=lnlinks href=#hl-1-3>3</a>
</span><span class=lnt id=hl-1-4><a class=lnlinks href=#hl-1-4>4</a>
</span><span class=lnt id=hl-1-5><a class=lnlinks href=#hl-1-5>5</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>[ERROR] 2024-08-04 12:45:23 - Failed to connect to database. Exception: java.sql.SQLException: Timeout expired. Attempted reconnect 3 times. Server: db.example.com, Port: 5432
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>System reboot initiated at 2024-08-04 03:00:00 by user: admin. Reason: Scheduled maintenance. Services stopped: web-server, database, cache. Estimated downtime: 15 minutes.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>DEBUG - 2024-08-04 09:30:15 - User johndoe performed action: file_upload. Filename: report_Q3_2024.pdf, Size: 2.3 MB, Duration: 5.2 seconds. Result: Success
</span></span></code></pre></td></tr></table></div></div><p><strong>Trace</strong></p><p>链路 是请求经过应用程序的路径。可以从一个宏观的角度看到请求在应用内的路径。链路追踪检测的主要问题是，如果仅靠开发人员“插桩”（英文 Instrument，有些地方也翻译成埋点，是指将有关系统状态的数据发送到监测系统）他们的代码是不够的。大量应用程序是使用可能需要额外工具的开源框架或库构建的。这在多语言架构的地方变得更加具有挑战性，因为要考虑到每种语言、框架和协议的不同。同时，增加插桩的成本也是比较高的，很难真正做到全面覆盖。另一方面大量的插桩也会占用比较高的计算资源。</p><h3 id=opentelementry>OpenTelementry<a hidden class=anchor aria-hidden=true href=#opentelementry>#</a></h3><p><a href=https://opentelemetry.io/docs/what-is-opentelemetry/>https://opentelemetry.io/docs/what-is-opentelemetry/</a></p><p>OpenTelemetry 简称 OTel， 是 CNCF （ Cloud Native Computing Foundation，云原生计算基金会，是一个开源软件基金会，致力于云原生技术的普及和可持续发展） 的一个可观测性项目。</p><p>OpenTelemetry 旨在提供可观测性领域的标准化方案，解决遥测数据的数据建模、采集、处理、导出等标准化问题，并能够将这些数据发送到你选择的后端（开源或商业均可）。这样你就可以建立不被供应商锁定的可观测，灵活地更改后端，不需要再次更改代码，重新进行插桩（Instrument）了</p><p>OpenTelemetry 不是凭空出现的。在 OpenTelemetry 出现之前，还出现过 OpenTracing 和 OpenCensus 两套标准。</p><h4 id=otel-架构>OTel 架构<a hidden class=anchor aria-hidden=true href=#otel-架构>#</a></h4><ul><li>跨语言实现（Specification）</li><li>API/SDK</li><li>接受、转换和导出遥测数据的工具（Opentelemetry Collector）</li></ul><p><strong>跨语言规范</strong></p><p>跨语言规范描述了所有实现的跨语言要求和数据模型，包括遥测客户端内部实现所需要的标准和定义，也包含与外部通信时需要实现的协议规范。跨语言规范主要包含了下面几类。</p><ul><li>API：定义用于生成和关联追踪、指标和日志的数据类型和操作。</li><li>SDK：定义 API 特定语言实现的要求，同时还定义配置、数据处理和导出等概念。</li><li>数据：定义遥测后端可以提供支持的 OpenTelemetry 协议 （OTLP） 和与供应商无关的语义约定。</li></ul><p>这里要重点说一下这个 OTLP 协议，它的全称是 OpenTelemetry Protocol，它是 OpenTelemetry 原生的遥测信号传递协议，虽然 OpenTelemetry 项目组件支持了Zipkin v2 或 Jaeger Thrift 协议格式的实现，但这种支持都是以第三方贡献库的形式提供的。只有 OTLP 是 OpenTelemetry 官方原生支持的格式。OTLP 的数据模型定义是基于 ProtoBuf 完成的，如果你需要实现一套可以收集 OTLP 遥测数据的后端服务，那就需要了解里面的内容（可以参考代码仓库 <a href=https://github.com/open-telemetry/opentelemetry-proto>opentelemetry-proto</a>）。</p><p><strong>API / SDK</strong></p><p>API 可以让开发者对应用程序代码进行插桩（Instrument），而 SDK 是 API 的具体实现，是和开发语言相关的。</p><p><a href=https://opentelemetry.io/docs/concepts/instrumentation/>https://opentelemetry.io/docs/concepts/instrumentation/</a></p><p>主要有两种方式实现插桩</p><ul><li>Code-based solutions via official APIs and SDKs for most languages</li><li>Zero-code solutions</li></ul><p>前者是使用OTel API为你的应用手动插桩监控，是零代码解决方案的重要补充
后者则是使用OTel为各种语言和库开发的SDK、OpenTelemetry 公共组件的设计模式或语言特性等来降低使用门槛。</p><p><strong>OpenTelemetry Collector</strong></p><p>Collector应该是OTel架构中最重要的部分</p><p><a href=https://opentelemetry.io/docs/collector/>https://opentelemetry.io/docs/collector/</a></p><blockquote><p>Vendor-agnostic way to receive, process and export telemetry data.</p></blockquote><p>Collector 针对如何接收、处理和导出遥测数据提供了与供应商无关的实现，消除了运行、操作和维护多个代理/收集器的需要，它支持将开源可观测性数据格式（例如 Jaeger、Prometheus 等）发送到一个或多个开源或商业后端。</p><p>在 Collector 的内部，有一套负责接收、处理和导出数据的流程被称为 Pipeline。 每个 Pipeline 由下面三部分组件组合而成。</p><p><img loading=lazy src=/posts/distributed/observability/002.png></p><ul><li>Receiever: 负责按照对应的协议格式监听和接收遥测数据，并把数据转给一个或多个Processor</li><li>Processor：负责加工处理遥测数据，如丢弃数据，增加信息，转发处理等，并把数据传递给下一个Processor或者一个或多个Exporter</li><li>Exporter：负责把数据传递给下一个接收端，比如将指标数据存储在Prometheus中</li></ul><p><strong>部署角度</strong></p><p>从部署的角度而言，Collector有下面两种模式</p><ul><li><p><strong>第一种模式可以统称为Agent模式。</strong> 它是把 Collector 部署在应用程序所在的主机内部（在 Kubernetes 环境中，可以使用 DaemonSet），或者在 K8s 环境中通过边车（Sidecar）的方式部署。这样，应用采集到的遥测数据可以直接传递给 Collector。</p></li><li><p><strong>第二种是Gateway模式。</strong> 它把 Collector 当作一个独立的中间件，应用会把采集到的遥测数据往这个中间件里传递。</p></li></ul><h4 id=otel技术方案>OTel技术方案<a hidden class=anchor aria-hidden=true href=#otel技术方案>#</a></h4><p>针对 OTel 有很多不同的技术实现方案，我们可以分别了解一下</p><p><strong>OTel to 开源工具组合</strong></p><p><a href=https://docs.guance.com/best-practices/cloud-native/opentelemetry-elk/>https://docs.guance.com/best-practices/cloud-native/opentelemetry-elk/</a></p><p>作为经典的遥测数据的处理架构，我们可以使用不同的开源工具将不同的遥测数据存储在不同的平台。比如log我们可以存储在ELK中，traces我们可以存储在Jeager中，而matrics可以保存在Promethues中并通过Grafana展示</p><p><img loading=lazy src=/posts/distributed/observability/003.png></p><p><strong>OTel to Grafana</strong></p><p><a href=https://docs.guance.com/best-practices/cloud-native/opentelemetry-grafana/>https://docs.guance.com/best-practices/cloud-native/opentelemetry-grafana/</a></p><p>随着 Grafana 进军可观测行业，Grafana的 Tempo 和 Loki 逐渐被很多人使用</p><ul><li><p>Grafana Tempo 一个开源易使用且大规模的分布式链路追踪后端。不依赖数据库或搜索引擎（如 Elasticsearch），直接把 trace 存到对象存储（比如 S3/MinIO），可横向扩展，超高性价比。</p></li><li><p>Loki 是 Grafana Labs 团队最新的开源项目，是一个水平可扩展，高可用性，多租户的日志聚合系统。相比于ELK的日志处理方案，Loki的设计是十分经济高效的，并不会建立全文索引，而是对数据进行Tag标注，类似于 Promethues，官方给的介绍就是 “Like Prometheus, but for logs”，非常适合云原生的场景。常常搭配 Promtail 使用。</p></li></ul><p><img loading=lazy src=/posts/distributed/observability/004.png></p><p><strong>OTel to 观测云平台</strong></p><p>阿里云、腾讯云、观测云等国内的云平台都提供了云可观测的解决方案，像国外也有ELK Stack、AWS CloudWatch、Grafana Labs等</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://whitea029.github.io/tags/distributed/>Distributed</a></li><li><a href=https://whitea029.github.io/tags/sast/>SAST</a></li></ul><nav class=paginav><a class=prev href=https://whitea029.github.io/posts/golang/interface/><span class=title>« Prev</span><br><span>硬核——你真的搞定Golang接口了么</span>
</a><a class=next href=https://whitea029.github.io/posts/sast/2025-second-class/><span class=title>Next »</span><br><span>SAST授课-从HTTP到RPC & 服务发现与注册</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://whitea029.github.io/>Whitea's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>